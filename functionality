# system wide userland


function reload.functionality()
{
  [[ -f /etc/functionality ]] && source /etc/functionality
}


function text.row.hl()
{
  [[ ! -f ${1} ]] && return 1
  local color="\e[01;30m"
  [[ ${2} ]] && case ${2} in
    red) color="\e[01;31m";;
    green) color="\e[01;32m";;
    yellow) color="\e[01;33m";;
    blue) color="\e[01;34m";;
    purple) color="\e[01;35m";;
    cyan) color="\e[01;36m";;
    lgray) color="\e[01;37m";;
  esac
  
  local IFS=$'\n'
  local c=0
  for i in $(cat ${1}); do
    [[ ${c} -eq 0 ]] && { echo $i; c=1; } || { echo -en $color; echo -n $i; echo -en "\e[00m"; echo ""; c=0; };
  done
}


## environ candles

function env.gcc.unset()
{
  [[ ${CFLAGS} ]] && unset CFLAGS CPPFLAGS MAKEFLAGS
  case $- in *i*) echo "CFLAGS CPPFLAGS MAKEFLAGS unset.";; esac
}


function env.gcc.set()
{
  # optimisation given by -O flag
  # coding standard given by -std flag
  # preprocessing error flags
  # cpu option flags
  # all of this shall be used on purpose.
  local march="x86-64"
  local mtune="native"
  [[ ${1} ]] && march=${1}
  [[ ${2} ]] && mtune=${2}
  CFLAGS="-march=$march -mtune=$mtune -fdiagnostics-color=always -pipe"
  CPPFLAGS=${CFLAGS}
  MAKEFLAGS=-j$(($(nproc)+1))
  export CFLAGS CPPFLAGS MAKEFLAGS
  case $- in *i*) echo $CFLAGS;; esac
}


# root access
if [[ $EUID -eq 0 ]]; then

  [[ -x /bin/ss ]] && {
    alias ss.ssh='ss -o state established "( dport = :ssh or sport :ssh )"'
    alias ss.tcp='ss -t -a'
    alias ss.udp='ss -u -a'
  }

  [[ -x /usr/bin/vim ]] && {
    [[ -f /etc/functionality ]] && \
      alias config.functionality="vim /etc/functionality"
    [[ -f /etc/ssh/sshd_config ]] && \
      alias config.sshd='vim /etc/sshd/sshd_config'
    [[ -f /etc/ssh/ssh_config ]] && \
      alias config.ssh='vim /etc/sshd/ssh_config'
    [[ -f /etc/ssl/openssl.cnf ]] && \
      alias config.ssl='vim /etc/ssl/openssl.cnf'
  }

  function hello.world()
  {
    echo "Hello, world."
  }

fi

