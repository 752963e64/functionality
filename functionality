# system wide userland
### oneshot
# This part is gonna vanish from script... if you load it
#from inside git repo issue ". functionality"
[[ -w $PWD/functionality ]] && {
  echo "oneshot"
  sed -i '/\x23\x23\x23 oneshot/,/\x23\x23\x23/d' $PWD/functionality
}
# it's magic, it has a name it's pretty looked ability however I've no job, oohhhh...
###


function reload.functionality()
{
  [[ -f /etc/functionality ]] && source /etc/functionality
}


# -----------------------------------------------------
## text
# -----------------------------------------------------


function text.row.hl()
{
  [[ ! -f ${1} ]] && return 1
  local color="\e[01;30m"
  [[ ${2} ]] && case ${2} in
    red) color="\e[01;31m";;
    green) color="\e[01;32m";;
    yellow) color="\e[01;33m";;
    blue) color="\e[01;34m";;
    purple) color="\e[01;35m";;
    cyan) color="\e[01;36m";;
  esac
  
  local IFS=$'\n'
  local c=0
  for i in $(cat ${1}); do
    [[ ${c} -eq 0 ]] && { echo $i; c=1; } || { echo -en $color; echo -n $i; echo -en "\e[00m"; echo ""; c=0; };
  done
}


# -----------------------------------------------------
## file
# -----------------------------------------------------

[[ -x /usr/bin/find ]] && {

  function find.file()
  {
    [[ -d ${1} && ${2} ]] || { echo "usage: find.file <path> <name>"; return 1; }
    find ${1} -type f -name ${2}
  }


  function find.dir()
  {
    [[ -d ${1} && ${2} ]] || { echo "usage: find.dir <path> <name>"; return 1; }
    find ${1} -type d -name ${2}
  }


  function find.link()
  {
    [[ -d ${1} && ${2} ]] || { echo "usage: find.link <path> <name>"; return 1; }
    find ${1} -type l -name ${2}
  }


  function inventory()
  {
    [[ ${1} -d ${2} ]] || { echo "usage: use inventory.<file|dir|link|all> <path>; instead."; return 1; }
    local opts
    case ${1} in
      dir) opts+='-type d -o -type l';;
      file) opts+='-type f -o -type l';;
      link) opts+='-type l';;
      all) opts+='-type f -o -type d -o -type l';;
    esac
    local fname="$USER.${1}.inventory-$(date "+%d-%m-%Y-%H%M%S").list"
    echo "# PATH=$PWD/${1}" > ~/${fname}
    find ${1} ${opts} >> ~/${fname}
    case $- in *i*) ls -alsh ~/${fname};; esac
  }

  function inventory.dir()
  {
    local listof=${FUNCNAME##*.}
    integrity $listof ${1}
  }

  function inventory.file()
  {
    local listof=${FUNCNAME##*.}
    integrity $listof ${1}
  }

  function inventory.link()
  {
    local listof=${FUNCNAME##*.}
    integrity $listof ${1}
  }

  function inventory.all()
  {
    local listof=${FUNCNAME##*.}
    integrity $listof ${1}
  }

  # --------------------------------------------------
  ## file integrity related
  # - one way hashing
  # --------------------------------------------------

  function integrity()
  {
    [[ ${1} && -d ${2} ]] || { echo "usage: use integrity.<md5|sha1|sha224|sha256|sha384|sha512> <path>; instead."; return 1; }
    local tmpfile="/tmp/lst.${1}sum"
    find ${2} -type f -exec ${1}sum {} \; > ${tmpfile}
    [[ $? -eq 0 ]] && { mv ${tmpfile} ${2}/.lst.${1}sum; } ||
    { case $- in *i*) echo "something went wrong while writing ${tmpfile}";; esac; return 1; }
    return 0
  }

  function integrity.check()
  {
    [[ ${1} && -d ${2} ]] || { echo "usage: integrity.check <md5|sha1|sha224|sha256|sha384|sha512> <path>."; return 1; }
    cd ${2} && ${1}sum -w --quiet -c .lst.${1}sum; }
    return $?
  }
  
  [[ -x /usr/bin/md5sum ]] && function integrity.md5()
  {
    local hashto=${FUNCNAME##*.}
    integrity $hashto ${1}
  }
  
  [[ -x /usr/bin/sha1sum ]] && function integrity.sha1()
  {
    local hashto=${FUNCNAME##*.}
    integrity $hashto ${1}
  }
  
  [[ -x /usr/bin/sha224sum ]] && function integrity.sha224()
  {
    local hashto=${FUNCNAME##*.}
    integrity $hashto ${1}
  }
  
  [[ -x /usr/bin/sha256sum ]] && function integrity.sha256()
  {
    local hashto=${FUNCNAME##*.}
    integrity $hashto ${1}
  }
  
  [[ -x /usr/bin/sha384sum ]] && function integrity.sha384()
  {
    local hashto=${FUNCNAME##*.}
    integrity $hashto ${1}
  }
  
  [[ -x /usr/bin/sha512sum ]] && function integrity.sha512()
  {
    local hashto=${FUNCNAME##*.}
    integrity $hashto ${1}
  }
}

# --------------------------------------------------
## backup related
# - TODO update archives.
# - TODO follow fs type limits.
# - TODO check/deduce size before compressing.
# --------------------------------------------------

[[ -x /usr/bin/tar ]] && {
  function backup()
  {
    [[ -d ${2} ]] || { echo "usage: use backup.<xz|gz|bz2> <path>; instead."; return 1; }
    local fname=$(date "+%d-%m-%Y-%H%M%S").tar.${1}
    local opts='-c'
    [[ -f /tmp/func.backup.v ]] && opts+='v'
    opts+='p'
    case $- in *i*) echo "Archiving ${2} to /tmp/${fname}";; esac
    case ${1} in
      bz2) opts+='j';;
      gz) opts+='z';;
      xz) opts+='J';;
    esac
    opts+='f'
    cd ${2} && tar ${opts} /tmp/${fname} .
  }
  
  function backup.v()
  {
    local opts="-f"
    [[ -f /tmp/func.backup.v ]] && {
      case $- in *i*) opts+='v';; esac
      rm ${opts} /tmp/func.backup.v
      return
    }
    echo -n "" > /tmp/func.backup.v
  }
  
  function backup.bz2()
  {
    local tarto=${FUNCNAME##*.}
    backup $tarto ${1}
  }
  
  function backup.gz()
  {
    local tarto=${FUNCNAME##*.}
    backup $tarto ${1}
  }
  
  function backup.xz()
  {
    local tarto=${FUNCNAME##*.}
    backup $tarto ${1}
  }
}

# ---------------------------------------------------
## network
# ---------------------------------------------------

# because in strainer it's free to leak
[[ -x /bin/ss ]] && {
  alias ss.ssh='ss -o state established "( dport = :ssh or sport = :ssh )"'
  alias ss.tcp='ss -t -a'
  alias ss.udp='ss -u -a'
}

# ---------------------------------------------------
## environ candles
# ---------------------------------------------------
function env()
{
  function proceed()
  {
    local IFS=$'\n'
    for i in $(/usr/bin/env $@); do
      echo -n "${i%%=*}=" && echo -en "\e[01;30m" && echo -n "${i#*=}" && echo -e "\e[00m";
    done
  }
  case $- in *i*) proceed $@;; *) /usr/bin/env $@;; esac
}


function env.gcc.unset()
{
  [[ ${CFLAGS} ]] && unset CFLAGS CPPFLAGS MAKEFLAGS
  case $- in *i*) echo "CFLAGS CPPFLAGS MAKEFLAGS unset.";; esac
}


function env.gcc.set()
{
  # optimisation given by -O flag
  # coding standard given by -std flag
  # preprocessing error flags
  # cpu option flags
  # all of this shall be used on purpose.
  local march="x86-64"
  local mtune="native"
  [[ ${1} ]] && march=${1}
  [[ ${2} ]] && mtune=${2}
  CFLAGS="-march=$march -mtune=$mtune -fdiagnostics-color=always -pipe"
  CPPFLAGS=${CFLAGS}
  MAKEFLAGS=-j$(($(nproc)+1))
  export CFLAGS CPPFLAGS MAKEFLAGS
  case $- in *i*) echo $CFLAGS;; esac
}


# root access
if [[ $EUID -eq 0 ]]; then

  [[ -x /usr/bin/vim ]] && {
    [[ -f /etc/functionality ]] && \
      alias config.functionality="vim /etc/functionality"
    [[ -f /etc/ssh/sshd_config ]] && \
      alias config.sshd='vim /etc/sshd/sshd_config'
    [[ -f /etc/ssh/ssh_config ]] && \
      alias config.ssh='vim /etc/sshd/ssh_config'
    [[ -f /etc/ssl/openssl.cnf ]] && \
      alias config.ssl='vim /etc/ssl/openssl.cnf'
  }

  function hello.world()
  {
    echo "Hello, world."
  }

fi

